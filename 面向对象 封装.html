<html>
<head>
  <title>面向对象 封装</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/302292 (zh-CN); Windows/6.1.7600 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="446"/>
<h1>面向对象 封装</h1>

<div>
<span><div><br/></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">面向对象三大特征：</span></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">    1. 封装</span></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">    2. 继承</span></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">    3  多态。</span></span></div><div style="text-align: center"><span style="font-size: 32px;"><span style="color: rgb(255, 0, 0);">static(静态)</span></span></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">概念</span></span></div><div> 如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。</div><div>     </div><div><span style="font-size: 21px;"><span style="color: rgb(255, 0, 0);">静态属性的访问方法</span></span></div><div>        静态成员变量的访问方式：</div><div><br/></div><div>                方式1： 可以使用对象进行访问。</div><div>                    格式： 对象.变量名。</div><div><br/></div><div>                方式二： 可以使用类名进行访问。</div><div>                    格式： 类名.变量名;</div><div><br/></div><div>            <span style="color: rgb(255, 0, 0);"><span style="font-size: 24px;">注意：</span></span></div><div>                1. 非静态的成员变量只能使用对象进行访问，不能使用类名进行访问。</div><div>                2. 千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据是真正需要被共享的时候</div><div>                才使用static修饰。</div><div><br/></div><div>        static修饰成员变量的应用场景： 如果一个数据需要被所有对象共享使用的时候，这时候即可好实用static修饰。</div><div><br/></div><div><br/></div><div>    2. static修饰成员函数:</div><div><br/></div><div><br/></div><div><br/></div><div>静态的成员变量只会在数据共享区中维护一份，而非静态成员变量的数据会在每个对象中都维护一份的。。</div><div>    static修饰方法（静态的成员方法）:</div><div><br/></div><div>        <span style="font-size: 21px;"><span style="color: rgb(255, 0, 0);">静态函数的访问方法</span></span></div><div><br/></div><div>            方式一：可以使用对象进行访问。</div><div>                    对象.静态的函数名();</div><div><br/></div><div>            方式二：可以使用类名进行访问。</div><div>                    类名.静态函数名字。</div><div><br/></div><div>        推荐使用是类名直接访问静态的成员。</div><div><br/></div><div><span style="color: rgb(255, 70, 53);"><span style="font-size: 19px;">静态的成员变量与非静态的成员变量的区别：</span></span></div><div>    1. 作用上的区别：</div><div>        1. 静态的成员变量的作用共享一个 数据给所有的对象使用。</div><div>        2. 非 静态的成员变量的作用是描述一类事物的公共属性。</div><div>    2. 数量与存储位置上的区别：</div><div>        1. 静态成员变量是存储方法 区内存中，而且只会存在一份数据。</div><div>        2. 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。</div><div>    3. 生命周期的区别：</div><div>        1. 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失。</div><div>        2.非静态的成员数据是随着对象的创建而存在，随着 对象被垃圾回收器回收而消失。</div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 21px;">静态函数要注意的事项：</span></span></div><div>    1. 静态函数是可以调用类名或者对象进行调用的，而非静态函数只能使用对象进行调用。</div><div>    2. 静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员。   </div><div>        原因：静态函数是可以使用类名直接调用的，这时候可能还没有存在对象，</div><div>        而非静态的 成员数据是随着对象 的存在而存在的。</div><div><br/></div><div>    3. 非静态的函数是可以直接访问静态与非静态的成员。</div><div>        原因：非静态函数只能由对象调用，当对象存在的时候，静态数据老早就已经存在了，而非静态</div><div>        数据也随着对象的创建而存在了。</div><div><br/></div><div>    4. 静态函数不能出现this或者super关键字。</div><div>        原因：因为静态的函数是可以使用类名调用的，一旦使用类名调用这时候不存在对象，而this</div><div>        关键字是代表了一个函数 的调用者对象，这时候产生了冲突。</div><div><br/></div><div><span style="color: rgb(255, 70, 53);"><span style="font-size: 16px;">静态的数据的生命周期：静态的成员变量数据是优先于对象存在的。</span></span></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 70, 53);">static什么时候修饰一个函数？</span></div><div><br/></div><div>    如果一个函数没有直接访问到非静态的成员时，那么就可以使用static修饰了。 一般用于工具类型的方法</div><div><br/></div><div><br/></div><div>静态函数不能访问非静态的成员？</div><div>     静态函数只要存在有对象，那么也可以访问非 静态的数据。只是不能直接访问而已。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div style="text-align: center"><span style="font-size: 32px;"><span style="color: rgb(255, 0, 0);">instanceof 关键字</span></span></div><div><br/></div><div><span style="font-size: 21px;"><span style="color: rgb(255, 0, 0);">instanceof关键字的作用</span></span>：判断一个对象是否属于指定的类别。</div><div><br/></div><div>instanceof关键字的使用前提：判断的对象与指定的类别必须要存在继承或者实现的关系。</div><div><br/></div><div><span style="font-size: 21px;"><span style="color: rgb(255, 0, 0);">instanceof关键字的使用格式</span></span>：</div><div><br/></div><div>        对象  instanceof 类别</div><div><br/></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 24px;">instanceof关键字的作用：</span></span></div><div>一般我们做强制类型转换之前都会使用该关键字先判断一把，然后在进行转换的。</div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div style="text-align: center"><span style="color: rgb(255, 0, 0);"><span style="font-size: 32px;">封装:</span></span></div><div><br/></div><div><br/></div><div><br/></div><div style="text-align: center"><span style="font-size: 32px;"><span style="color: rgb(255, 0, 0);"><br/></span></span></div><div style="text-align: center"><span style="font-size: 32px;"><span style="color: rgb(255, 0, 0);"><br/></span></span></div><div><span style="font-size: 24px;"><span style="color: rgb(255, 0, 0);">什么是封装</span></span></div><div>封装指的是将对象的属性等隐藏在对象内部,不允许外部程序直</div><div>接访问对象属性,而是通过该类所提供的方法来实现对属性的操</div><div>作和访问</div><div><span style="font-size: 19px;"><br/></span></div><div><span style="font-size: 19px;"><br/></span></div><div><span style="font-size: 24px;"><span style="color: rgb(255, 0, 0);">封装的作用</span></span></div><div>对一个类或对象实现良好的封装可以实现的目的</div><div>让使用者只能通过事先预定的方法来访问数据,从而可以在该</div><div>方法里加入控制逻辑,限制对属性的不合理访问和操作,提高代</div><div>码的可维护性和健壮性</div><div><span style="font-size: 24px;"><span style="color: rgb(255, 0, 0);"><br/></span></span></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 24px;">权限修饰符</span></span></div><div><br/></div><div>权限修饰符：权限修饰符就是控制变量可见范围的。</div><div><br/></div><div>public :  公共的。 public修饰的成员变量或者方法任何人都可以直接访问。</div><div><br/></div><div>private ： 私有的， private修饰的成员变量或者方法只能在本类中进行直接访问。</div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);"><span style="font-size: 24px;">使用方法</span></span></div><div><br/></div><div>    1. 使用private修饰需要被封装的属性。</div><div>    2. 提供一个公共的方法设置或者获取该私有的成员属性。</div><div>             命名规范：</div><div>                set属性名();</div><div>                get属性名();</div><div><br/></div><div>疑问： 封装一定要提供get或者set方法吗？</div><div>        不一定， 根据需求而定的。</div><div><br/></div><div>规范 ： 在现实开发中一般实体类的所有成员属性（成员变量）都要封装起来。</div><div>将对象的属性用private来修饰,提供public修饰的方法,让外部</div><div>程序通过调用该公有的方法控制对这些属性进行安全的访问和</div><div>操作</div><div><br/></div><div><span style="font-size: 21px;"><span style="color: rgb(255, 0, 0);">作用好处</span></span></div><div>    1. 提高数据的安全性。</div><div>    2. 操作简单。</div><div>    3. 隐藏了实现</div><div><br/></div><div style="text-align: center"><span style="color: rgb(255, 0, 0);"><span style="font-size: 19px;">main函数的详解：</span></span></div><div><br/></div><div>    public ： 公共的。 权限是最大，在任何情况下都可以访问。 private </div><div>        原因： 为了保证让jvm在任何情况下都可以访问到main方法。</div><div><br/></div><div>    static:  静态。静态可以让jvm调用main函数的时候更加的方便。不需要通过对象调用。</div><div><br/></div><div>    void:  没有返回值。 因为返回的数据是 给 jvm，而jvm使用这个数据是没有意义的。所以就不要了。</div><div><br/></div><div><br/></div><div>    main: 函数名。   注意： main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已。</div><div><br/></div><div><br/></div><div>    arguments ：担心某些程序在启动需要参数。</div><div><br/></div><div><br/></div><div style="text-align: center"><br/></div></span>
</div></body></html> 